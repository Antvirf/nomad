diff -ur internal/hcl/scanner/scanner.go internal/hcl/scanner/scanner.go
--- internal/hcl/scanner/scanner.go	2018-11-13 11:04:23.605311203 -0600
+++ internal/hcl/scanner/scanner.go	2018-11-13 10:26:31.681243725 -0600
@@ -123,11 +123,6 @@
 func (s *Scanner) Scan() token.Token {
 	ch := s.next()
 
-	// skip white space
-	for isWhitespace(ch) {
-		ch = s.next()
-	}
-
 	var tok token.Type
 
 	// token text markings
@@ -148,59 +143,77 @@
 		s.tokPos.Column = s.lastLineLen
 	}
 
-	switch {
-	case isLetter(ch):
-		tok = token.IDENT
-		lit := s.scanIdentifier()
-		if lit == "true" || lit == "false" {
-			tok = token.BOOL
+	// <DEVIATION-FROM-STANDARD-HCL>
+	//   Instead of skipping whitespace, we now roll up all whitespace into a
+	//   new WHITESPACE token so that the scanner can emit identical whitespace
+	//   back out when we sanitize the HCL to fix multiline strings.
+	// </DEVIATION-FROM-STANDARD-HCL>
+	var wsCount int
+	for isWhitespace(ch) {
+		ch = s.next()
+		wsCount++
+	}
+
+	if wsCount > 0 {
+		if ch != eof {
+			s.unread()
 		}
-	case isDecimal(ch):
-		tok = s.scanNumber(ch)
-	default:
-		switch ch {
-		case eof:
-			tok = token.EOF
-		case '"':
-			tok = token.STRING
-			s.scanString()
-		case '#', '/':
-			tok = token.COMMENT
-			s.scanComment(ch)
-		case '.':
-			tok = token.PERIOD
-			ch = s.peek()
-			if isDecimal(ch) {
-				tok = token.FLOAT
-				ch = s.scanMantissa(ch)
-				ch = s.scanExponent(ch)
-			}
-		case '<':
-			tok = token.HEREDOC
-			s.scanHeredoc()
-		case '[':
-			tok = token.LBRACK
-		case ']':
-			tok = token.RBRACK
-		case '{':
-			tok = token.LBRACE
-		case '}':
-			tok = token.RBRACE
-		case ',':
-			tok = token.COMMA
-		case '=':
-			tok = token.ASSIGN
-		case '+':
-			tok = token.ADD
-		case '-':
-			if isDecimal(s.peek()) {
-				ch := s.next()
-				tok = s.scanNumber(ch)
-			} else {
-				tok = token.SUB
+		tok = token.WHITESPACE
+	} else {
+		switch {
+		case isLetter(ch):
+			tok = token.IDENT
+			lit := s.scanIdentifier()
+			if lit == "true" || lit == "false" {
+				tok = token.BOOL
 			}
+		case isDecimal(ch):
+			tok = s.scanNumber(ch)
 		default:
-			s.err("illegal char")
+			switch ch {
+			case eof:
+				tok = token.EOF
+			case '"':
+				tok = token.STRING
+				s.scanString()
+			case '#', '/':
+				tok = token.COMMENT
+				s.scanComment(ch)
+			case '.':
+				tok = token.PERIOD
+				ch = s.peek()
+				if isDecimal(ch) {
+					tok = token.FLOAT
+					ch = s.scanMantissa(ch)
+					ch = s.scanExponent(ch)
+				}
+			case '<':
+				tok = token.HEREDOC
+				s.scanHeredoc()
+			case '[':
+				tok = token.LBRACK
+			case ']':
+				tok = token.RBRACK
+			case '{':
+				tok = token.LBRACE
+			case '}':
+				tok = token.RBRACE
+			case ',':
+				tok = token.COMMA
+			case '=':
+				tok = token.ASSIGN
+			case '+':
+				tok = token.ADD
+			case '-':
+				if isDecimal(s.peek()) {
+					ch := s.next()
+					tok = s.scanNumber(ch)
+				} else {
+					tok = token.SUB
+				}
+			default:
+				s.err("illegal char")
+			}
 		}
 	}
 
diff -ur internal/hcl/scanner/scanner_test.go internal/hcl/scanner/scanner_test.go
--- internal/hcl/scanner/scanner_test.go	2018-11-13 11:04:23.605311203 -0600
+++ internal/hcl/scanner/scanner_test.go	2018-11-13 09:37:44.178971863 -0600
@@ -243,6 +243,15 @@
 	"float",
 }
 
+func scanSkipWhitespace(s *Scanner) token.Token {
+	for {
+		tok := s.Scan()
+		if tok.Type != token.WHITESPACE {
+			return tok
+		}
+	}
+}
+
 func TestPosition(t *testing.T) {
 	// create artifical source code
 	buf := new(bytes.Buffer)
@@ -256,7 +265,7 @@
 	s := New(buf.Bytes())
 
 	pos := token.Pos{"", 4, 1, 5}
-	s.Scan()
+	scanSkipWhitespace(s)
 	for _, listName := range orderedTokenLists {
 
 		for _, k := range tokenLists[listName] {
@@ -274,7 +283,7 @@
 			}
 			pos.Offset += 4 + len(k.text) + 1     // 4 tabs + token bytes + newline
 			pos.Line += countNewlines(k.text) + 1 // each token is on a new line
-			s.Scan()
+			scanSkipWhitespace(s)
 		}
 	}
 	// make sure there were no token-internal errors reported by scanner
@@ -330,10 +339,15 @@
 		literal   string
 	}{
 		{token.COMMENT, "// This should have Windows line endings\r"},
+		{token.WHITESPACE, "\n"},
 		{token.IDENT, `resource`},
+		{token.WHITESPACE, ` `},
 		{token.STRING, `"aws_instance"`},
+		{token.WHITESPACE, ` `},
 		{token.STRING, `"foo"`},
+		{token.WHITESPACE, ` `},
 		{token.LBRACE, `{`},
+		{token.WHITESPACE, "\r\n    "},
 		{token.IDENT, `user_data`},
 		{token.ASSIGN, `=`},
 		{token.HEREDOC, "<<HEREDOC\r\n    test script\r\nHEREDOC\r\n"},
@@ -464,7 +478,7 @@
 
 	s := New([]byte(complexHCL))
 	for _, l := range literals {
-		tok := s.Scan()
+		tok := scanSkipWhitespace(s)
 		if l.tokenType != tok.Type {
 			t.Errorf("got: %s want %s for %s\n", tok, l.tokenType, tok.String())
 		}
@@ -499,6 +513,8 @@
 }
 
 func testError(t *testing.T, src, pos, msg string, tok token.Type) {
+	t.Helper()
+
 	s := New([]byte(src))
 
 	errorCalled := false
@@ -515,7 +531,7 @@
 		}
 	}
 
-	tk := s.Scan()
+	tk := scanSkipWhitespace(s)
 	if tk.Type != tok {
 		t.Errorf("tok = %s, want %s for %q", tk, tok, src)
 	}
@@ -528,6 +544,8 @@
 }
 
 func testTokenList(t *testing.T, tokenList []tokenPair) {
+	t.Helper()
+
 	// create artifical source code
 	buf := new(bytes.Buffer)
 	for _, ident := range tokenList {
@@ -536,7 +554,7 @@
 
 	s := New(buf.Bytes())
 	for _, ident := range tokenList {
-		tok := s.Scan()
+		tok := scanSkipWhitespace(s)
 		if tok.Type != ident.tok {
 			t.Errorf("tok = %q want %q for %q\n", tok, ident.tok, ident.text)
 		}
diff -ur internal/hcl/token/token.go internal/hcl/token/token.go
--- internal/hcl/token/token.go	2018-11-13 11:04:23.605311203 -0600
+++ internal/hcl/token/token.go	2018-11-13 10:27:16.737404086 -0600
@@ -26,6 +26,10 @@
 	ILLEGAL Type = iota
 	EOF
 	COMMENT
+	// <DEVIATION-FROM-STANDARD-HCL>
+	//   WHITESPACE is a new token.
+	// </DEVIATION-FROM-STANDARD-HCL>
+	WHITESPACE
 
 	identifier_beg
 	IDENT // literals
@@ -58,6 +62,10 @@
 
 	EOF:     "EOF",
 	COMMENT: "COMMENT",
+	// <DEVIATION-FROM-STANDARD-HCL>
+	//   WHITESPACE is a new token.
+	// </DEVIATION-FROM-STANDARD-HCL>
+	WHITESPACE: "WHITESPACE",
 
 	IDENT:  "IDENT",
 	NUMBER: "NUMBER",
